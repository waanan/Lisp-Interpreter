#lang racket
(provide run simple-exp? every?)
(define (simple-exp? exp)
  (or (number? exp)
      (boolean? exp)
      (symbol? exp)
      (and (eq? (car exp) '-) (simple-exp? (cadr exp)) (simple-exp? (caddr exp)))
      (and (eq? (car exp) 'zero?) (simple-exp? (cadr exp)))
      (eq? (car exp) 'proc)
      (and (eq? (car exp) 'sum) (every? simple-exp? (cdr exp)))))
(define (every? pred exp)
  (cond ((null? exp) #t)
        ((pred (car exp)) (every? pred (cdr exp)))
        (else #f)))
(define (value-of-simple-exp exp env)
  (cond ((number? exp) exp)
        ((boolean? exp) exp)
        ((symbol? exp) (apply-env exp env))
        ((eq? (car exp) '-) (- (value-of-simple-exp (cadr exp) env)
                               (value-of-simple-exp (caddr exp) env)))
        ((eq? (car exp) 'sum) (apply + (map (lambda (x) (value-of-simple-exp x env)) (cdr exp))))
        ((eq? (car exp) 'zero?) (zero? (value-of-simple-exp (cadr exp) env)))
        ((eq? (car exp) 'proc) (list 'lambda (cadr exp) (caddr exp) env))
        (else (display "Simple Exp Parse Error!\n"))))

(define (apply-cont cont val)
  (cont val))
(define (end-cont val)
  (display "End of Computation!\n")
  (display "Answer is ")
  (display val))
(define (value-of/k exp env cont)
  (cond ((simple-exp? exp)
         (apply-cont cont 
                     (value-of-simple-exp exp env)))
        ((eq? (car exp) 'let)
         (let* ((temp (cadr exp))
                (vars (map car temp))
                (vals (map (lambda (x) (value-of-simple-exp x env)) (map cadr temp)))
                (body (caddr exp)))
           (value-of/k body (extend-env* vars vals env) cont)))
        ((eq? (car exp) 'letrec)
         (let* ((temp (cadr exp))
                (p-names (map car temp))
                (p-varss (map cadr temp))
                (p-bodies (map caddr temp))
                (body (caddr exp)))
           (value-of/k body (extend-env-rec* p-names p-varss p-bodies env) cont)))
        ((eq? (car exp) 'if)
         (if (value-of-simple-exp (cadr exp) env)
             (value-of/k (caddr exp) env cont)
             (value-of/k (cadddr exp) env cont)))
        (else (let ((rator-proc (value-of-simple-exp (car exp) env))
                    (rand-vals (map (lambda (simple) (value-of-simple-exp simple env)) (cdr exp))))
                (apply-procedure/k rator-proc rand-vals cont)))))

(define (apply-procedure/k proc1 args cont)
  (let ((vars (cadr proc1))
        (body (caddr proc1))
        (saved-env (cadddr proc1)))
    (value-of/k body (extend-env* vars args saved-env) cont)))
                
         

(define (run exp)
  (value-of/k exp empty-env end-cont))
         
(define (extend-env* vars vals saved-env)
  (cons (list vars vals) saved-env))
(define (extend-env-rec* p-names p-varss p-bodies saved-env)
  (cons (list p-names p-varss p-bodies) saved-env))
(define (find-in-env var vars vals o-env)
  (cond ((null? vars) (apply-env var o-env))
        ((eq? var (car vars)) (car vals))
        (else (find-in-env var (cdr vars) (cdr vals) o-env))))
(define (find-rec-in-env var p-names p-varss p-bodies env)
  (cond ((null? p-names) (apply-env var (cdr env)))
        ((eq? var (car p-names)) (list 'lambda (car p-varss) (car p-bodies) env))
        (else (find-rec-in-env var (cdr p-names) (cdr p-varss) (cdr p-bodies) env))))
(define (apply-env var env)
  (cond ((null? env) (display (string-append "No such " (symbol->string var) " in Env")))
        (else (let ((c-env (car env))
                    (o-env (cdr env)))
                (cond ((= (length c-env) 2)
                       (let ((vars (car c-env))
                             (vals (cadr c-env)))
                         (find-in-env var vars vals o-env)))
                      ((= (length c-env) 3)
                       (let ((p-names (car c-env))
                             (p-varss (cadr c-env))
                             (p-bodies (caddr c-env)))
                         (find-rec-in-env var p-names p-varss p-bodies env)))
                      (else (display "Env Storage Error!")))))))
;env test
(define empty-env '())       
;(define test-env 
;  (extend-env-rec* (list 'add) 
;                   (list '(x y))
;                   (list '(+ x y))
;                   (extend-env* '(x y) '(1 2) empty-env)))
                